<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>小项目-词法分析器 | The Yue</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/huyue.github.io/img/avatar.png"><!-- index.css--><link rel="stylesheet" href="/huyue.github.io/css/index.css?v=1.8.6"><!-- inject head--><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><!-- aplayer--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/11.0.5/swiper-bundle.min.css"><!-- fancybox ui--><!-- katex--><!-- Open Graph--><meta name="description" content="小项目-词法分析器1.理论 一个完整的编译器，大致会经历如下几个阶段 各个阶段的职责，简单描述如下： 词法分析：对源文件进行扫描，将源文件的字符划分为一个一个的记号(token) (注：类似中文中的分词)。 语法分析：根据语法规则将 Token 序列构造为语法树。 对语法树的各个结点之间"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="The Yue"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/huyue.github.io/img/avatar.png"><link rel="apple-touch-icon" href="/huyue.github.io/img/avatar.png" sizes="180x180"><script>console.log(
    "%c Program: Hexo %c Theme: Solitude %c Version: v1.8.6",
    "border-radius:5px 0 0 5px;padding: 5px 10px;color:white;background:#ff3842;",
    "padding: 5px 10px;color:white;background:#3e9f50;",
    "border-radius:0 5px 5px 0;padding: 5px 10px;background:#0084ff;color:white;"
);
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/huyue.github.io/',
    algolia: undefined,
    localsearch: undefined,
    runtime: '2024-04-16 00:00:00',
    lazyload: {
        enable: true,
        error: '/img/error_load.png'
    },
    copyright: {"limit":50,"author":"作者: 胡越","link":"链接: ","source":"来源: The Yue","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {
        enable: true,
        limit: 200,
        expand: true,
        copy: true,
        syntax: 'highlight.js'
    },
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可"},
    aside: {
        sayhello: {
            morning: '一日之计在于晨',
            noon: '吃饱了才有力气干活',
            afternoon: '集中精力，攻克难关',
            night: '不要太劳累了，早睡更健康',
            goodnight: '睡个好觉，保证精力充沛',
        },
        sayhello2: ["🎮 电竞游戏爱好者"],
    },
    covercolor: {
        enable: false
    },
    comment: false,
    lightbox: 'null',
    post_ai: false,
    right_menu: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false,
}</script><meta name="generator" content="Hexo 7.1.1"></head><body id="body"><!-- universe--><canvas id="universe"></canvas><!-- loading--><div id="loading-box" onclick="preloader.endLoading();" style="zoom:1"><div class="loading-bg"><img class="loading-img nolazyload" src="https://api.qjqq.cn/api/MiYouShe" alt="loading image"></div></div><script>const preloader = {
    endLoading: () => {
        document.getElementById('loading-box').classList.toggle('loaded');
    },
    initLoading: () => {
        document.getElementById('loading-box').classList.remove('loaded');
    },
    removePaceDone: () => {
        document.getElementById('body').classList = 'pace-done';
    }
}
window.addEventListener('load', () => {
    preloader.endLoading();
});
window.addEventListener('pjax:send', () => {
    preloader.initLoading();
});
document.addEventListener('pjax:complete', () => {
    preloader.endLoading();
});</script><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="solitude st-close-fill"></i></div><div class="button-group"><div class="console-btn-item"><span class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换"><i class="solitude st-moon-clear-fill"></i></span></div><div class="console-btn-item" id="consoleHideAside"><span class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制"><i class="solitude st-side-bar-fill"></i></span></div><div class="console-btn-item" id="consoleMusic" onclick="sco.musicToggle()"><span class="music-switch" title="音乐开关"><i class="solitude st-disc-fill"></i></span></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/huyue.github.io/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/huyue.github.io/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/huyue.github.io/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span>显示模式</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/huyue.github.io/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/huyue.github.io/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/huyue.github.io/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/huyue.github.io/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/huyue.github.io/moments/"><i class="solitude  st-wifi-fill"></i><span>友链鱼塘</span></a></li><li><a class="site-page child" href="/huyue.github.io/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li><li><a class="site-page child" href="javascript:travelling()"><i class="solitude  st-gift-fill"></i><span>宝藏博主</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>分享</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/huyue.github.io/equipment/"><i class="solitude  st-laptop-line"></i><span>装备</span></a></li><li><a class="site-page child" href="/huyue.github.io/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/huyue.github.io/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/huyue.github.io/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/huyue.github.io/tags/%E9%A1%B9%E7%9B%AE/">项目<sup>1</sup></a><a href="/huyue.github.io/tags/%E6%89%8B%E5%86%8C/">手册<sup>29</sup></a><a href="/huyue.github.io/tags/%E6%95%99%E7%A8%8B/">教程<sup>1</sup></a><a href="/huyue.github.io/tags/%E7%AC%94%E8%AE%B0/">笔记<sup>15</sup></a><a href="/huyue.github.io/tags/%E7%AE%97%E6%B3%95/">算法<sup>2</sup></a><a href="/huyue.github.io/tags/%E5%88%86%E4%BA%AB/">分享<sup>1</sup></a><a href="/huyue.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<sup>1</sup></a><a href="/huyue.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构<sup>1</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/huyue.github.io/" title="返回博客主页"><span class="title">越の博客</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">小项目-词法分析器</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/huyue.github.io/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/huyue.github.io/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/huyue.github.io/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/huyue.github.io/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/huyue.github.io/moments/"><i class="solitude  st-wifi-fill"></i><span>友链鱼塘</span></a></li><li><a class="site-page child" href="/huyue.github.io/links/"><i class="solitude  st-group-fill"></i><span>友情链接</span></a></li><li><a class="site-page child" href="javascript:travelling()"><i class="solitude  st-gift-fill"></i><span>宝藏博主</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>分享</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/huyue.github.io/equipment/"><i class="solitude  st-laptop-line"></i><span>装备</span></a></li><li><a class="site-page child" href="/huyue.github.io/tlink/"><i class="solitude  st-tools-fill"></i><span>工具箱</span></a></li><li><a class="site-page child" href="/huyue.github.io/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/huyue.github.io/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机一篇文章" href="javascript:void(0);"><i class="solitude st-signal-tower-fill"></i></a></div><div class="nav-button" id="nav-console"><a class="console_switchbutton" onclick="sco.showConsole()" title="中控台" href="javascript:void(0);"><i class="solitude st-dashboard-fill"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude st-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude st-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://api.qjqq.cn/api/Img?sort=acg&amp;random=701" alt="小项目-词法分析器"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/huyue.github.io/tags/%E9%A1%B9%E7%9B%AE/"><span class="tags-name tags-punctuation">项目</span></a></div></div></div></div><h1 class="post-title">小项目-词法分析器</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2024-04-23 09:34:00"><i class="post-meta-icon solitude st-calendar-todo-fill"></i><time datetime="2024-04-23T01:34:00.000Z">2024-04-23T01:34:00.000Z</time></span><span class="post-meta-date" title="最后更新于 2024-06-19 22:32:46"><i class="post-meta-icon solitude st-refresh-line"></i><time datetime="2024-06-19T14:32:46.481Z">2024-06-19T14:32:46.481Z</time></span><span class="post-meta-position" title="作者IP归属地为武汉"><i class="post-meta-icon solitude st-map-pin-fill"></i><span>武汉</span></span><a class="post-meta-pv" href="/huyue.github.io/2024/04/23/2024-4-23-%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/" title="文章热度"><i class="post-meta-icon solitude st-fire-fill"></i><span id="busuanzi_value_page_pv"><i class="solitude st-loading-line"></i></span></a></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="小项目-词法分析器"><a href="#小项目-词法分析器" class="headerlink" title="小项目-词法分析器"></a>小项目-词法分析器</h1><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1.理论"></a>1.理论</h2><blockquote>
<p>一个完整的编译器，大致会经历如下几个阶段</p>
<p><img src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202401161925339.png?align=center#padding#800px"></p>
<p>各个阶段的职责，简单描述如下：</p>
<blockquote>
<ol>
<li><p>词法分析：对源文件进行扫描，将源文件的字符划分为一个一个的记号(token) (注：类似中文中的分词)。 </p>
</li>
<li><p>语法分析：根据语法规则将 Token 序列构造为语法树。</p>
</li>
<li><p>对语法树的各个结点之间的关系进行检查，检查语义规则是否有被违背，同时对语法树进行必要的优化，此为语义分析。</p>
</li>
<li><p>遍历语法树的结点，将各结点转化为中间代码，并按特定的顺序拼装起来，此为中间代码生成。</p>
</li>
<li><p>对中间代码进行优化</p>
</li>
<li><p>将中间代码转化为目标代码</p>
</li>
<li><p>对目标代码进行优化，生成最终的目标程序</p>
</li>
</ol>
</blockquote>
<p>以上阶段的划分仅仅是逻辑上的划分。实际的编译器中，常常会将几个阶段组合在一起，甚至还可以能省略其中某些阶段。</p>
</blockquote>
<h3 id="1-1词法分析"><a href="#1-1词法分析" class="headerlink" title="1.1词法分析"></a>1.1词法分析</h3><blockquote>
<p>编译器扫描源文件的字符流，过滤掉字符流中的空格、注释等，并将其划分为一个个的 token，生成 token 序列。</p>
<p>例如下面的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = value + sum(5, 123); </span><br></pre></td></tr></table></figure>

<p>将被拆分为11个 token ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a           标识符</span><br><span class="line">=           赋值运算符</span><br><span class="line">value       标识符</span><br><span class="line">+           加号</span><br><span class="line">sum         标识符</span><br><span class="line">(           左括号</span><br><span class="line">5           整数</span><br><span class="line">,           逗号</span><br><span class="line">123         整数</span><br><span class="line">)           右括号</span><br><span class="line">;           分号</span><br></pre></td></tr></table></figure>

<p>这个步骤和中文中分词非常相似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我/喜欢/美丽动人的/茜茜/。  </span><br></pre></td></tr></table></figure>

<p>本质上，词法分析阶段所做的事情就是模式匹配。判断哪些字符属于标识符，哪些字符属于关键字，哪些字符属于整数…</p>
</blockquote>
<h3 id="1-2-有限状态机"><a href="#1-2-有限状态机" class="headerlink" title="1.2 有限状态机"></a>1.2 有限状态机</h3><blockquote>
<p>那么该如何做模式匹配呢？这就要用到有限状态机了 (注：术语都是纸老虎，有限状态机一般都是用 switch + while + if 语句实现的，按我自己的理解为，还未扫描元素的时候，那个目标串字符串(token)符合所有的字符条件，扫描完第一个元素，判断剩余还满足什么字符串的条件，再扫描，直到可以确定出目标字符串是什么类型的字符串为止)。</p>
<ul>
<li>单字符 Token，可以直接识别: ; ) ( { } 等</li>
<li>双字符 Token，需要用 if 语句进行判断：+&#x3D;, -&#x3D;, *&#x3D;, &#x3D;&#x3D;, !&#x3D;     </li>
<li>多字符 Token，需要用 while 语句一直读取到结束标志符: 标识符，字符串，数字，字符等。</li>
</ul>
<p>接下来我们重点看一下：如何判断一个Token到底是标识符还是关键字。这里我们采用Trie树的方式进行判断，因为不管是从空间上还是时间上，Trie树的方式都优于哈希表的方式。在逻辑上，我们可以将 C 语言的关键字组织成下面这样的形式：</p>
<p><img src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202401161925132.jpg?align=center#padding"></p>
<p>具体实现的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (first) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;reak&quot;</span>, TOKEN_BREAK);</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: &#123;</span><br><span class="line">	<span class="type">char</span> second = scanner.start[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">switch</span> (second) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&quot;se&quot;</span>, TOKEN_CASE);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&quot;ar&quot;</span>, TOKEN_CHAR);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: &#123;</span><br><span class="line">		<span class="keyword">if</span> (scanner.start[<span class="number">3</span>] == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> checkKeyword(<span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;st&quot;</span>, TOKEN_CONST);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> checkKeyword(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&quot;tinue&quot;</span>, TOKEN_CONTINUE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: &#123;</span><br><span class="line">	<span class="type">char</span> second = scanner.start[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (second == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> checkKeyword(<span class="number">2</span>, <span class="number">6</span>, <span class="string">&quot;efault&quot;</span>, TOKEN_DEFAULT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (scanner.start[<span class="number">2</span>] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> checkKeyword(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;uble&quot;</span>, TOKEN_DOUBLE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> checkKeyword(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;do&quot;</span>, TOKEN_DO);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="2-效果"><a href="#2-效果" class="headerlink" title="2.效果"></a>2.效果</h2><blockquote>
<p>该词法分析器既能交互式地运行，也能够处理‘.c’文件</p>
<p>交互方式效果为：</p>
<p><img src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://s21.ax1x.com/2024/04/23/pk9lUM9.png" alt="交互式运行结果"></p>
<p>对‘.c’文件进行词法分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error: xxx.\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span> dest[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">double</span> b = <span class="number">0.2</span>;</span><br><span class="line">	<span class="type">char</span> *str = <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sprintf</span>(dest, <span class="string">&quot;a = %d, b = %.2f, str = %s&quot;</span>, a, b, str);</span><br><span class="line">	<span class="built_in">puts</span>(dest);</span><br><span class="line"></span><br><span class="line">	FILE *fp = fopen(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to open file.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(fp, <span class="string">&quot;str = %s, a = %d, b = %.2f&quot;</span>, str, a, b);</span><br><span class="line">	fclose(fp);</span><br><span class="line"></span><br><span class="line">	FILE *fp2 = fopen(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;failed to open file.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> var1;</span><br><span class="line">	<span class="type">double</span> var2;</span><br><span class="line">	<span class="type">char</span> var3[<span class="number">1024</span>];</span><br><span class="line">	<span class="built_in">fscanf</span>(fp2, <span class="string">&quot;str = %[^,], a = %d, b = %lf&quot;</span>, var3, &amp;var1, &amp;var2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 格式的读字符串dest</span></span><br><span class="line">	<span class="type">int</span> num1;</span><br><span class="line">	<span class="type">double</span> num2;</span><br><span class="line">	<span class="type">char</span> str2[<span class="number">1024</span>];</span><br><span class="line">	<span class="built_in">sscanf</span>(dest, <span class="string">&quot;a = %d, b = %lf, str = %s&quot;</span>, &amp;num1, &amp;num2, str2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果为：</p>
<p><img src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://s21.ax1x.com/2024/04/23/pk9l0Vx.png" alt="处理文件"></p>
</blockquote>
<h2 id="3-代码框架"><a href="#3-代码框架" class="headerlink" title="3.代码框架"></a>3.代码框架</h2><blockquote>
<p>main.c的代码框架：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scanner.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c中的核心逻辑</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *source)</span> &#123;</span><br><span class="line">	initScanner(source);	<span class="comment">// 初始化词法分析器</span></span><br><span class="line">	<span class="type">int</span> line = <span class="number">-1</span>;  <span class="comment">// 用于记录当前处理的行号,-1表示还未开始解析</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">		Token token = scanToken();  <span class="comment">// 获取下一个TOKEN</span></span><br><span class="line">		<span class="keyword">if</span> (token.line != line) &#123;		<span class="comment">// 如果Token中记录行和现在的lin不同就执行换行打印的效果		</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, token.line); </span><br><span class="line">			line = token.line; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;		<span class="comment">// 没有换行的打印效果</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;   | &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">char</span> *str = convert_to_str(token);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s &#x27;%.*s&#x27;\n&quot;</span>, str, token.length, token.start);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (token.type == TOKEN_EOF) &#123;</span><br><span class="line">			<span class="keyword">break</span>;	<span class="comment">// 读到TOKEN_EOF结束循环</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// repl是&quot;read evaluate print loop&quot;的缩写</span></span><br><span class="line"><span class="comment">// repl 函数定义了一个交互式的读取-求值-打印循环（REPL）逻辑</span></span><br><span class="line"><span class="comment">// 它允许用户输入源代码行，逐行进行词法分析，并打印分析结果</span></span><br><span class="line"><span class="comment">// 也就是说启动时没有主动给出一个命令行参数表示文件路径的话,那么就进行交互式界面进行词法分析</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">repl</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">	<span class="comment">// 这里应该存在一个死循环,而且要逐行的读取键盘输入fgets</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户输入文件名，将整个文件的内容读入内存，并在末尾添加&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">// 注意: 这里应该使用动态内存分配，因此应该事先确定文件的大小。</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">readFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数表示对传入的文件路径名的字符串进行处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">runFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="comment">// 处理&#x27;.c&#x27;文件:用户输入文件名，分析整个文件，并将结果输出</span></span><br><span class="line">	<span class="comment">// 这个代码非常简单，我帮你直接写好</span></span><br><span class="line">	<span class="comment">// 会调用上面的readFile函数，根据文件路径名生成一个包含文件全部字符信息的字符串</span></span><br><span class="line">	<span class="type">char</span> *source = readFile(path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用run函数处理源文件生成的字符串</span></span><br><span class="line">	run(source);</span><br><span class="line">	<span class="comment">// 及时释放资源</span></span><br><span class="line">	<span class="built_in">free</span>(source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 主函数支持操作系统传递命令行参数</span></span><br><span class="line"><span class="comment">* 然后通过判断参数的个数:</span></span><br><span class="line"><span class="comment">* 1.如果没有主动传入参数(argc=1),因为第一个参数总会传入一个当前可执行文件的目录作为命令行参数</span></span><br><span class="line"><span class="comment">* 此时执行repl函数</span></span><br><span class="line"><span class="comment">* 2.如果传递了一个参数(argc=2),说明传递了一个参数,将传递的参数视为某个源代码的路径</span></span><br><span class="line"><span class="comment">* 然后调用runFile函数,传入该源代码文件的路径,处理源文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">		repl();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">		runFile(argv[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果主动传入超过一个命令行参数.即参数传递有误,错误处理</span></span><br><span class="line">		<span class="comment">// 告诉用户正确的使用函数的方式</span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: scanner [path]\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scanner.h的代码框架，这里面主要是一些结构体的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SCANNER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCANNER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个TokenType枚举，用于标记不同种类的Token</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 单字符 Token */</span></span><br><span class="line">    TOKEN_LEFT_PAREN,        <span class="comment">// &#x27;(&#x27; 左小括号</span></span><br><span class="line">    TOKEN_RIGHT_PAREN,       <span class="comment">// &#x27;)&#x27; 右小括号</span></span><br><span class="line">    TOKEN_LEFT_BRACKET,      <span class="comment">// &#x27;[&#x27; 左中括号</span></span><br><span class="line">    TOKEN_RIGHT_BRACKET,     <span class="comment">// &#x27;]&#x27; 右中括号</span></span><br><span class="line">    TOKEN_LEFT_BRACE,        <span class="comment">// &#x27;&#123;&#x27; 左大括号</span></span><br><span class="line">    TOKEN_RIGHT_BRACE,       <span class="comment">// &#x27;&#125;&#x27; 右大括号</span></span><br><span class="line">    TOKEN_COMMA,             <span class="comment">// &#x27;,&#x27; 逗号</span></span><br><span class="line">    TOKEN_DOT,               <span class="comment">// &#x27;.&#x27; 点</span></span><br><span class="line">    TOKEN_SEMICOLON,         <span class="comment">// &#x27;;&#x27; 分号</span></span><br><span class="line">    TOKEN_TILDE,             <span class="comment">// &#x27;~&#x27; 波浪号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 可能是单字符或双字符的Token */</span></span><br><span class="line">    TOKEN_PLUS,                  <span class="comment">// &#x27;+&#x27; 加号</span></span><br><span class="line">    TOKEN_PLUS_PLUS,             <span class="comment">// &#x27;++&#x27; 自增运算符</span></span><br><span class="line">    TOKEN_PLUS_EQUAL,            <span class="comment">// &#x27;+=&#x27; 加赋运算符</span></span><br><span class="line">    TOKEN_MINUS,                 <span class="comment">// &#x27;-&#x27; 减号或负号</span></span><br><span class="line">    TOKEN_MINUS_MINUS,           <span class="comment">// &#x27;--&#x27; 自减运算符</span></span><br><span class="line">    TOKEN_MINUS_EQUAL,           <span class="comment">// &#x27;-=&#x27; 减赋运算符</span></span><br><span class="line">    TOKEN_MINUS_GREATER,         <span class="comment">// &#x27;-&gt;&#x27; 结构体指针访问</span></span><br><span class="line">    TOKEN_STAR,                  <span class="comment">// &#x27;*&#x27; 乘号</span></span><br><span class="line">    TOKEN_STAR_EQUAL,            <span class="comment">// &#x27;*=&#x27; 乘赋运算符</span></span><br><span class="line">    TOKEN_SLASH,                 <span class="comment">// &#x27;/&#x27; 除号</span></span><br><span class="line">    TOKEN_SLASH_EQUAL,           <span class="comment">// &#x27;/=&#x27; 除赋运算符</span></span><br><span class="line">    TOKEN_PERCENT,               <span class="comment">// &#x27;%&#x27; 取模运算符</span></span><br><span class="line">    TOKEN_PERCENT_EQUAL,         <span class="comment">// &#x27;%=&#x27; 取模赋运算符</span></span><br><span class="line">    TOKEN_AMPER,                 <span class="comment">// &#x27;&amp;&#x27; 按位与运算符</span></span><br><span class="line">    TOKEN_AMPER_EQUAL,           <span class="comment">// &#x27;&amp;=&#x27; 按位与赋运算符</span></span><br><span class="line">    TOKEN_AMPER_AMPER,           <span class="comment">// &#x27;&amp;&amp;&#x27; 逻辑与运算符</span></span><br><span class="line">    TOKEN_PIPE,                  <span class="comment">// &#x27;|&#x27; 按位或运算符</span></span><br><span class="line">    TOKEN_PIPE_EQUAL,            <span class="comment">// &#x27;|=&#x27; 按位或赋运算符</span></span><br><span class="line">    TOKEN_PIPE_PIPE,             <span class="comment">// &#x27;||&#x27; 逻辑或运算符</span></span><br><span class="line">    TOKEN_HAT,                   <span class="comment">// &#x27;^&#x27; 按位异或运算符</span></span><br><span class="line">    TOKEN_HAT_EQUAL,             <span class="comment">// &#x27;^=&#x27; 按位异或赋运算符</span></span><br><span class="line">    TOKEN_EQUAL,                 <span class="comment">// &#x27;=&#x27; 赋值运算符</span></span><br><span class="line">    TOKEN_EQUAL_EQUAL,           <span class="comment">// &#x27;==&#x27; 等于比较运算符</span></span><br><span class="line">    TOKEN_BANG,                  <span class="comment">// &#x27;!&#x27; 逻辑非运算符</span></span><br><span class="line">    TOKEN_BANG_EQUAL,            <span class="comment">// &#x27;!=&#x27; 不等于比较运算符</span></span><br><span class="line">    TOKEN_LESS,                  <span class="comment">// &#x27;&lt;&#x27; 小于比较运算符</span></span><br><span class="line">    TOKEN_LESS_EQUAL,            <span class="comment">// &#x27;&lt;=&#x27; 小于等于比较运算符</span></span><br><span class="line">    TOKEN_LESS_LESS,             <span class="comment">// &#x27;&lt;&lt;&#x27; 左移运算符</span></span><br><span class="line">    TOKEN_GREATER,               <span class="comment">// &#x27;&gt;&#x27; 大于比较运算符</span></span><br><span class="line">    TOKEN_GREATER_EQUAL,         <span class="comment">// &#x27;&gt;=&#x27; 大于等于比较运算符</span></span><br><span class="line">    TOKEN_GREATER_GREATER,       <span class="comment">// &#x27;&gt;&gt;&#x27; 右移运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的三字符Token都去掉了 &gt;&gt;= &lt;&lt;= 实现它们也没什么特殊的，但会很无聊繁琐，所以就都去掉了</span></span><br><span class="line">    <span class="comment">/* 多字节Token: 标识符、字符、字符串、数字 */</span></span><br><span class="line">    TOKEN_IDENTIFIER,            <span class="comment">// 标识符</span></span><br><span class="line">    TOKEN_CHARACTER,             <span class="comment">// 字符</span></span><br><span class="line">    TOKEN_STRING,                <span class="comment">// 字符串</span></span><br><span class="line">    TOKEN_NUMBER,                <span class="comment">// 数字，包含整数和浮点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关键字Token 涉及C99所有关键字 */</span></span><br><span class="line">    TOKEN_SIGNED, TOKEN_UNSIGNED,</span><br><span class="line">    TOKEN_CHAR, TOKEN_SHORT, TOKEN_INT, TOKEN_LONG,</span><br><span class="line">    TOKEN_FLOAT, TOKEN_DOUBLE,</span><br><span class="line">    TOKEN_STRUCT, TOKEN_UNION, TOKEN_ENUM, TOKEN_VOID,</span><br><span class="line">    TOKEN_IF, TOKEN_ELSE, TOKEN_SWITCH, TOKEN_CASE, TOKEN_DEFAULT,</span><br><span class="line">    TOKEN_WHILE, TOKEN_DO, TOKEN_FOR,</span><br><span class="line">    TOKEN_BREAK, TOKEN_CONTINUE, TOKEN_RETURN, TOKEN_GOTO,</span><br><span class="line">    TOKEN_CONST, TOKEN_SIZEOF, TOKEN_TYPEDEF,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：#define #include这样的预处理指令 不是关键字</span></span><br><span class="line">    <span class="comment">// 辅助Token</span></span><br><span class="line">    <span class="comment">// 词法分析阶段也是可以检测出一些错误的 比如$只能在字符和字符串中 比如字符串&quot;acb 缺少右边双引号</span></span><br><span class="line">    <span class="comment">// 词法分析阶段不进行错误处理，只是将错误的Token信息抛出，以待后续统一进行处理</span></span><br><span class="line">    <span class="comment">// 流水线架构每个阶段都可能出错，如果每个阶段都进行错误处理，那代码的可维护性就太差了</span></span><br><span class="line">    TOKEN_ERROR,                 <span class="comment">// 错误Token 词法分析时遇到无法识别的文本</span></span><br><span class="line">    TOKEN_EOF                    <span class="comment">// 文件结束Token 表示源代码已经分析完毕</span></span><br><span class="line">&#125; TokenType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 词法分析器的目的就是生产一个一个的Token对象 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TokenType type;		<span class="comment">// Token的类型, 取任一枚举值</span></span><br><span class="line">    <span class="comment">// Token的起始字符指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *start;	<span class="comment">// start指向source中的字符，source为读入的源代码。</span></span><br><span class="line">    <span class="type">int</span> length;		    <span class="comment">// length表示这个Token的长度</span></span><br><span class="line">    <span class="type">int</span> line;		    <span class="comment">// line表示这个Token在源代码的哪一行, 方便后面的报错和描述Token</span></span><br><span class="line">&#125; Token;	<span class="comment">// 这个Token只涉及一个字符指针指向源代码的字符信息,没有在内部保存字符数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 词法分析器Scanner 进行初始化 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initScanner</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *source)</span>;	<span class="comment">// 源代码字符串(这里涉及一个将源码转换成字符串的函数)</span></span><br><span class="line"><span class="comment">// 核心API, 调用scanToken(), 就生产一个Token, 也就是源代码中下一段字符数据的Token</span></span><br><span class="line">Token <span class="title function_">scanToken</span><span class="params">()</span>;	<span class="comment">// 当Token返回的是TOKEN_EOF时，源文件被消耗完毕，词法分析结束</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// !SCANNER_H</span></span></span><br></pre></td></tr></table></figure>

<p>scanner.c的代码框架，词法分析器的实现细节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scanner.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *start;		<span class="comment">// 指向当前正在扫描的Token的起始字符</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *current;	<span class="comment">// 词法分析器当前正在处理的Token的字符,一开始它就是start开始,直到遍历完整个Token,指向该Token的下一个字符</span></span><br><span class="line">	<span class="type">int</span> line;		<span class="comment">// 记录当前Token所处的行</span></span><br><span class="line">&#125; Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量结构体对象</span></span><br><span class="line"><span class="type">static</span> Scanner scanner;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initScanner</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *source)</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化全局变量Scanner</span></span><br><span class="line">	scanner.start = source;</span><br><span class="line">	scanner.current = source;</span><br><span class="line">	scanner.line = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面我给大家提供了很多会用到的辅助函数,建议使用</span></span><br><span class="line"><span class="comment">// 判断当前字符是不是字母或者下划线</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">isAlpha</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) ||</span><br><span class="line">		(c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) ||</span><br><span class="line">		c == <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断当前字符是不是数字</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">isDigit</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断Scanner当前正在处理的字符是不是空字符,判断是不是处理完了</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">isAtEnd</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *scanner.current == <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// curr指针前进一个字符,并返回之前curr指针指向的元素</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="title function_">advance</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *scanner.current++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查看当前正在处理的字符是什么,curr不动</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *scanner.current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前正在处理的字符不是空字符,那就瞥一眼下一个字符是什么,curr不动</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="title function_">peekNext</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (isAtEnd()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *(scanner.current + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前正在处理的字符是不是符合预期,如果符合curr前进一位</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">match</span><span class="params">(<span class="type">char</span> expected)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (isAtEnd()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">// 如果正在处理的是空字符,那就返回false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (peek() != expected) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">// 如果不符合预期,也返回false</span></span><br><span class="line">	&#125;</span><br><span class="line">	scanner.current++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// 只有符合预期才会返回true 而且curr会前进一位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据传入的TokenType类型来制造返回一个Token</span></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">makeToken</span><span class="params">(TokenType type)</span> &#123;</span><br><span class="line">	Token token;</span><br><span class="line">	token.type = type;</span><br><span class="line">	token.start = scanner.start;</span><br><span class="line">	token.length = (<span class="type">int</span>)(scanner.current - scanner.start);	<span class="comment">// 计算Token字符串的长度</span></span><br><span class="line">	token.line = scanner.line;</span><br><span class="line">	<span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到不能解析的情况时，我们创建一个ERROR Token. 比如：遇到@，$等符号时，比如字符串，字符没有对应的右引号时。</span></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">errorToken</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span> &#123;</span><br><span class="line">	Token token;</span><br><span class="line">	token.type = TOKEN_ERROR;</span><br><span class="line">	token.start = message;</span><br><span class="line">	token.length = (<span class="type">int</span>)<span class="built_in">strlen</span>(message);</span><br><span class="line">	token.line = scanner.line;</span><br><span class="line">	<span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">skipWhitespace</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 跳过空白字符: &#x27; &#x27;, &#x27;\r&#x27;, &#x27;\t&#x27;, &#x27;\n&#x27;和注释</span></span><br><span class="line">	<span class="comment">// 注释以&#x27;//&#x27;开头, 一直到行尾</span></span><br><span class="line">	<span class="comment">// 注意更新scanner.line！</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提示: 整个过程需要跳过中间的很多字符,所以需要死循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于检查当前扫描的Token的类型是不是type 如果是就返回type</span></span><br><span class="line"><span class="type">static</span> TokenType <span class="title function_">checkKeyword</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> length, <span class="type">const</span> <span class="type">char</span> *rest, TokenType type)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		start: 待检查序列的起始字符下标</span></span><br><span class="line"><span class="comment">			比如要检查关键字break，那么在case b的前提下，需要传入reak来进行检查</span></span><br><span class="line"><span class="comment">			这里start就等于1，scanner.start[1]</span></span><br><span class="line"><span class="comment">		length: 待检查序列的长度，如果检查的是break，就是检查剩余的reak</span></span><br><span class="line"><span class="comment">			需要传入4</span></span><br><span class="line"><span class="comment">		rest指针，待检查的剩余序列字符串，这里直接传入一个字面值字符串就行了</span></span><br><span class="line"><span class="comment">			比如检查break，传入&quot;reak&quot;就好了</span></span><br><span class="line"><span class="comment">		type：你要检查的关键字Token的类型，比如检查break，那就传入Token_BREAK</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (scanner.current - scanner.start == start + length &amp;&amp;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">					int memcmp(const void *s1, const void *s2, size_t n);</span></span><br><span class="line"><span class="comment">					这里的参数分别是：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					s1：指向第一块内存区域的指针。</span></span><br><span class="line"><span class="comment">					s2：指向第二块内存区域的指针。</span></span><br><span class="line"><span class="comment">					n：要比较的字节数。</span></span><br><span class="line"><span class="comment">					memcmp 函数会逐字节比较 s1 和 s2 指向的内存区域，直到有不相等的字节或比较了 n 个字节为止。</span></span><br><span class="line"><span class="comment">					如果两个内存区域完全相同，</span></span><br><span class="line"><span class="comment">					则 memcmp 返回 0；如果第一个不同的字节在 s1 中的值小于 s2 中对应的值，返回负数；</span></span><br><span class="line"><span class="comment">					反之，返回正数。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="built_in">memcmp</span>(scanner.start + start, rest, length) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TOKEN_IDENTIFIER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TokenType <span class="title function_">identifierType</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 确定identifier类型主要有两种方式：</span></span><br><span class="line">	<span class="comment">// 1. 将所有的关键字放入哈希表中，然后查表确认 </span></span><br><span class="line">	<span class="comment">// Key-Value 就是&quot;关键字-TokenType&quot; 可以做 但存在额外内存占用且效率不如下一个方式好</span></span><br><span class="line">	<span class="comment">// 2. 将所有的关键字放入Trie树(字典查找树)中，然后查表确认</span></span><br><span class="line">	<span class="comment">// Trie树的方式不管是空间上还是时间上都优于哈希表的方式</span></span><br><span class="line">	<span class="comment">// 用switch...switch...if组合构建逻辑上的trie树</span></span><br><span class="line">	<span class="type">char</span> first = scanner.start[<span class="number">0</span>];	<span class="comment">// 该Token的第一个字符</span></span><br><span class="line">	<span class="keyword">switch</span> (first) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;reak&quot;</span>, TOKEN_BREAK);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没有进switch一定是标识符</span></span><br><span class="line">	<span class="keyword">return</span> TOKEN_IDENTIFIER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前Token的开头是下划线或字母判断它是不是标识符Token</span></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">identifier</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 判断curr指针当前正在处理的字符是不是 字母 下划线 数字</span></span><br><span class="line">	<span class="keyword">while</span> (isAlpha(peek()) || isDigit(peek())) &#123;</span><br><span class="line">		advance();  <span class="comment">// 继续前进看下一个字符 直到碰到下一个字符不是字母 下划线 以及数字 结束Token</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当while循环结束时，curr指针指向的是该Token字符串的下一个字符</span></span><br><span class="line">	<span class="comment">// 这个函数的意思是: 只要读到字母或下划线开头的Token我们就进入标识符模式</span></span><br><span class="line">	<span class="comment">// 然后一直找到此Token的末尾</span></span><br><span class="line">	<span class="comment">// 但代码运行到这里还不确定Token是标识符还是关键字, 因为它可能是break, var, goto, max_val...</span></span><br><span class="line">	<span class="comment">// 于是执行identifierType()函数，它是用来确定Token类型的</span></span><br><span class="line">	<span class="keyword">return</span> makeToken(identifierType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">number</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 简单起见，我们将NUMBER的规则定义如下:</span></span><br><span class="line">	<span class="comment">// 1. NUMBER可以包含数字和最多一个&#x27;.&#x27;号</span></span><br><span class="line">	<span class="comment">// 2. &#x27;.&#x27;号前面要有数字</span></span><br><span class="line">	<span class="comment">// 3. &#x27;.&#x27;号后面也要有数字</span></span><br><span class="line">	<span class="comment">// 这些都是合法的NUMBER: 123, 3.14</span></span><br><span class="line">	<span class="comment">// 这些都是不合法的NUMBER: 123., .14(虽然在C语言中合法)</span></span><br><span class="line">	<span class="comment">// 提示: 这个过程需要不断的跳过中间的数字包括小数点,所以也需要循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">string</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 字符串以&quot;开头，以&quot;结尾，而且不能跨行</span></span><br><span class="line">	<span class="comment">// 为了简化工作量,简化了字符串</span></span><br><span class="line">	<span class="comment">// 如果下一个字符不是末尾也不是双引号，全部跳过(curr可以记录长度，不用担心)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">character</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 字符&#x27;开头，以&#x27;结尾，而且不能跨行</span></span><br><span class="line">	<span class="comment">// 如果下一个字符不是末尾也不是单引号，全部跳过(curr可以记录长度，不用担心)</span></span><br><span class="line">	<span class="comment">// 这两个函数不能说一模一样，也是几乎一样</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理无法识别的字符</span></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">errorTokenWithChar</span><span class="params">(<span class="type">char</span> character)</span> &#123;</span><br><span class="line">	<span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line">	<span class="comment">// 将无法识别的字符是什么输出</span></span><br><span class="line">	<span class="built_in">sprintf</span>(message, <span class="string">&quot;Unexpected character: %c&quot;</span>, character);</span><br><span class="line">	<span class="keyword">return</span> errorToken(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scanner核心逻辑,用于返回一个制作好的Token</span></span><br><span class="line">Token <span class="title function_">scanToken</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 跳过前置空白字符和注释</span></span><br><span class="line">	skipWhitespace();</span><br><span class="line">	<span class="comment">// 记录下一个Token的起始位置</span></span><br><span class="line">	scanner.start = scanner.current;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果已经处理完毕了 直接返回TOKEN_EOF</span></span><br><span class="line">	<span class="keyword">if</span> (isAtEnd()) &#123;</span><br><span class="line">		<span class="keyword">return</span> makeToken(TOKEN_EOF);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// curr指针现在指向Token的第二个字符,但这个字符c仍然是第一个字符的值</span></span><br><span class="line">	<span class="type">char</span> c = advance();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果Token的第一个字符是字母和下划线就进入标识符的处理模式</span></span><br><span class="line">	<span class="keyword">if</span> (isAlpha(c)) &#123;</span><br><span class="line">		<span class="keyword">return</span> identifier();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果Token的第一个字符是数字,那就进入数字的处理模式</span></span><br><span class="line">	<span class="keyword">if</span> (isDigit(c)) &#123;</span><br><span class="line">		<span class="keyword">return</span> number();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果Token的第一个字符既不是数字也不是字母和下划线,那么就switch处理它</span></span><br><span class="line">	<span class="keyword">switch</span> (c) &#123;</span><br><span class="line">		<span class="comment">// 第一部分: 处理单字符Token</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">return</span> makeToken(TOKEN_LEFT_PAREN);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: <span class="keyword">return</span> makeToken(TOKEN_RIGHT_PAREN);</span><br><span class="line">		<span class="comment">// ...TODO</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 可单可双字符的Token处理会稍微复杂一点,但不多</span></span><br><span class="line">			<span class="comment">// 如果Token的第一个字符是+号</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">		<span class="comment">// 如果Token的第二个字符也是+,那就生产++双字符Token返回</span></span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;+&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_PLUS_PLUS);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_PLUS_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ...TODO</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>: <span class="keyword">return</span> <span class="built_in">string</span>(); <span class="comment">// 如果Token的第一个字符是双引号,那就解析出字符串Token返回</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="keyword">return</span> character();	<span class="comment">// 如果Token的第一个字符是单引号,那就解析出字符Token返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果上述处理都没有处理成功,都没有生成合适的Token,说明该字符无法识别</span></span><br><span class="line">	<span class="keyword">return</span> errorTokenWithChar(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tool.h 与 tool.c 将枚举的int类型转换为char*类型的辅助函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scanner.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">convert_to_str</span><span class="params">(Token token)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tool.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">convert_to_str</span><span class="params">(Token token)</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> (token.type) &#123;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_LEFT_PAREN: <span class="keyword">return</span> <span class="string">&quot;LEFT_PAREN&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_RIGHT_PAREN: <span class="keyword">return</span> <span class="string">&quot;RIGHT_PAREN&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_LEFT_BRACKET: <span class="keyword">return</span> <span class="string">&quot;LEFT_BRACKET&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_RIGHT_BRACKET: <span class="keyword">return</span> <span class="string">&quot;RIGHT_BRACKET&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_LEFT_BRACE: <span class="keyword">return</span> <span class="string">&quot;LEFT_BRACE&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_RIGHT_BRACE: <span class="keyword">return</span> <span class="string">&quot;RIGHT_BRACE&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_COMMA: <span class="keyword">return</span> <span class="string">&quot;COMMA&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_DOT: <span class="keyword">return</span> <span class="string">&quot;DOT&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_SEMICOLON: <span class="keyword">return</span> <span class="string">&quot;SEMICOLON&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_TILDE: <span class="keyword">return</span> <span class="string">&quot;TILDE&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_PLUS: <span class="keyword">return</span> <span class="string">&quot;PLUS&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_PLUS_PLUS: <span class="keyword">return</span> <span class="string">&quot;PLUS_PLUS&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_PLUS_EQUAL: <span class="keyword">return</span> <span class="string">&quot;PLUS_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_MINUS: <span class="keyword">return</span> <span class="string">&quot;MINUS&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_MINUS_MINUS: <span class="keyword">return</span> <span class="string">&quot;MINUS_MINUS&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_MINUS_EQUAL: <span class="keyword">return</span> <span class="string">&quot;MINUS_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_MINUS_GREATER: <span class="keyword">return</span> <span class="string">&quot;MINUS_GREATER&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_STAR: <span class="keyword">return</span> <span class="string">&quot;STAR&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_STAR_EQUAL: <span class="keyword">return</span> <span class="string">&quot;STAR_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_SLASH: <span class="keyword">return</span> <span class="string">&quot;SLASH&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_SLASH_EQUAL: <span class="keyword">return</span> <span class="string">&quot;SLASH_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_PERCENT: <span class="keyword">return</span> <span class="string">&quot;PERCENT&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_PERCENT_EQUAL: <span class="keyword">return</span> <span class="string">&quot;PERCENT_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_AMPER: <span class="keyword">return</span> <span class="string">&quot;AMPER&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_AMPER_EQUAL: <span class="keyword">return</span> <span class="string">&quot;AMPER_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_AMPER_AMPER: <span class="keyword">return</span> <span class="string">&quot;AMPER_AMPER&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_PIPE: <span class="keyword">return</span> <span class="string">&quot;PIPE&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_PIPE_EQUAL: <span class="keyword">return</span> <span class="string">&quot;PIPE_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_PIPE_PIPE: <span class="keyword">return</span> <span class="string">&quot;PIPE_PIPE&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_HAT: <span class="keyword">return</span> <span class="string">&quot;HAT&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_HAT_EQUAL: <span class="keyword">return</span> <span class="string">&quot;HAT_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_EQUAL: <span class="keyword">return</span> <span class="string">&quot;EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_EQUAL_EQUAL: <span class="keyword">return</span> <span class="string">&quot;EQUAL_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_BANG: <span class="keyword">return</span> <span class="string">&quot;BANG&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_BANG_EQUAL: <span class="keyword">return</span> <span class="string">&quot;BANG_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_LESS: <span class="keyword">return</span> <span class="string">&quot;LESS&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_LESS_EQUAL: <span class="keyword">return</span> <span class="string">&quot;LESS_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_LESS_LESS: <span class="keyword">return</span> <span class="string">&quot;LESS_LESS&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_GREATER: <span class="keyword">return</span> <span class="string">&quot;GREATER&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_GREATER_EQUAL: <span class="keyword">return</span> <span class="string">&quot;GREATER_EQUAL&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_GREATER_GREATER: <span class="keyword">return</span> <span class="string">&quot;GREATER_GREATER&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_IDENTIFIER: <span class="keyword">return</span> <span class="string">&quot;IDENTIFIER&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_CHARACTER: <span class="keyword">return</span> <span class="string">&quot;CHARACTER&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_STRING: <span class="keyword">return</span> <span class="string">&quot;STRING&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_NUMBER: <span class="keyword">return</span> <span class="string">&quot;NUMBER&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_SIGNED: <span class="keyword">return</span> <span class="string">&quot;SIGNED&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_UNSIGNED: <span class="keyword">return</span> <span class="string">&quot;UNSIGNED&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_CHAR: <span class="keyword">return</span> <span class="string">&quot;CHAR&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_SHORT: <span class="keyword">return</span> <span class="string">&quot;SHORT&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_INT: <span class="keyword">return</span> <span class="string">&quot;INT&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_LONG: <span class="keyword">return</span> <span class="string">&quot;LONG&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_FLOAT: <span class="keyword">return</span> <span class="string">&quot;FLOAT&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_DOUBLE: <span class="keyword">return</span> <span class="string">&quot;DOUBLE&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_STRUCT: <span class="keyword">return</span> <span class="string">&quot;STRUCT&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_UNION: <span class="keyword">return</span> <span class="string">&quot;UNION&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_ENUM: <span class="keyword">return</span> <span class="string">&quot;ENUM&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_VOID: <span class="keyword">return</span> <span class="string">&quot;VOID&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_IF: <span class="keyword">return</span> <span class="string">&quot;IF&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_ELSE: <span class="keyword">return</span> <span class="string">&quot;ELSE&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_SWITCH: <span class="keyword">return</span> <span class="string">&quot;SWITCH&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_CASE: <span class="keyword">return</span> <span class="string">&quot;CASE&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_DEFAULT: <span class="keyword">return</span> <span class="string">&quot;DEFAULT&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_WHILE: <span class="keyword">return</span> <span class="string">&quot;WHILE&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_DO: <span class="keyword">return</span> <span class="string">&quot;DO&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_FOR: <span class="keyword">return</span> <span class="string">&quot;FOR&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_BREAK: <span class="keyword">return</span> <span class="string">&quot;BREAK&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_CONTINUE: <span class="keyword">return</span> <span class="string">&quot;CONTINUE&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_RETURN: <span class="keyword">return</span> <span class="string">&quot;RETURN&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_GOTO: <span class="keyword">return</span> <span class="string">&quot;GOTO&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_CONST: <span class="keyword">return</span> <span class="string">&quot;CONST&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_SIZEOF: <span class="keyword">return</span> <span class="string">&quot;SIZEOF&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_TYPEDEF: <span class="keyword">return</span> <span class="string">&quot;TYPEDEF&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_ERROR: <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> TOKEN_EOF: <span class="keyword">return</span> <span class="string">&quot;EOF&quot;</span>;</span><br><span class="line">	<span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="4-实现词法分析器"><a href="#4-实现词法分析器" class="headerlink" title="4.实现词法分析器"></a>4.实现词法分析器</h2><blockquote>
<p>main.c实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scanner.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c中的核心逻辑</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *source)</span> &#123;</span><br><span class="line">	initScanner(source);	<span class="comment">// 初始化词法分析器</span></span><br><span class="line">	<span class="type">int</span> line = <span class="number">-1</span>;  <span class="comment">// 用于记录当前处理的行号,-1表示还未开始解析</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">		Token token = scanToken();  <span class="comment">// 获取下一个TOKEN</span></span><br><span class="line">		<span class="keyword">if</span> (token.line != line) &#123;		<span class="comment">// 如果Token中记录行和现在的lin不同就执行换行打印的效果		</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%4d &quot;</span>, token.line); </span><br><span class="line">			line = token.line; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;		<span class="comment">// 没有换行的打印效果</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;   | &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">char</span> *str = convert_to_str(token);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s &#x27;%.*s&#x27;\n&quot;</span>, str, token.length, token.start);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (token.type == TOKEN_EOF) &#123;</span><br><span class="line">			<span class="keyword">break</span>;	<span class="comment">// 读到TOKEN_EOF结束循环</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// repl是&quot;read evaluate print loop&quot;的缩写</span></span><br><span class="line"><span class="comment">// repl 函数定义了一个交互式的读取-求值-打印循环（REPL）逻辑</span></span><br><span class="line"><span class="comment">// 它允许用户输入源代码行，逐行进行词法分析，并打印分析结果</span></span><br><span class="line"><span class="comment">// 也就是说启动时没有主动给出一个命令行参数表示文件路径的话,那么就进行交互式界面进行词法分析</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">repl</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// TODO</span></span><br><span class="line">	<span class="comment">// 这里应该存在一个死循环,而且要逐行的读取键盘输入fgets</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">	<span class="type">char</span> get_char[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (fgets(get_char, <span class="number">1024</span>, <span class="built_in">stdin</span>)) &#123;</span><br><span class="line">		run(get_char);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户输入文件名，将整个文件的内容读入内存，并在末尾添加&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">// 注意: 这里应该使用动态内存分配，因此应该事先确定文件的大小。</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">readFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	FILE* fp = fopen(path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;无法打开文件%s&quot;</span>, path);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="type">int</span> len = ftell(fp);</span><br><span class="line">	rewind(fp);<span class="comment">//计算出文件长度，并且将指针回退到文件开头</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* file = <span class="built_in">calloc</span>(len+<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fread(file, <span class="keyword">sizeof</span>(<span class="type">char</span>), len, fp);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数表示对传入的文件路径名的字符串进行处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">runFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="comment">// 处理&#x27;.c&#x27;文件:用户输入文件名，分析整个文件，并将结果输出</span></span><br><span class="line">	<span class="comment">// 这个代码非常简单，我帮你直接写好</span></span><br><span class="line">	<span class="comment">// 会调用上面的readFile函数，根据文件路径名生成一个包含文件全部字符信息的字符串</span></span><br><span class="line">	<span class="type">char</span> *source = readFile(path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用run函数处理源文件生成的字符串</span></span><br><span class="line">	run(source);</span><br><span class="line">	<span class="comment">// 及时释放资源</span></span><br><span class="line">	<span class="built_in">free</span>(source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 主函数支持操作系统传递命令行参数</span></span><br><span class="line"><span class="comment">* 然后通过判断参数的个数:</span></span><br><span class="line"><span class="comment">* 1.如果没有主动传入参数(argc=1),因为第一个参数总会传入一个当前可执行文件的目录作为命令行参数</span></span><br><span class="line"><span class="comment">* 此时执行repl函数</span></span><br><span class="line"><span class="comment">* 2.如果传递了一个参数(argc=2),说明传递了一个参数,将传递的参数视为某个源代码的路径</span></span><br><span class="line"><span class="comment">* 然后调用runFile函数,传入该源代码文件的路径,处理源文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">		repl();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">		runFile(argv[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果主动传入超过一个命令行参数.即参数传递有误,错误处理</span></span><br><span class="line">		<span class="comment">// 告诉用户正确的使用函数的方式</span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: scanner [path]\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scanner.c实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scanner.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* start;		<span class="comment">// 指向当前正在扫描的Token的起始字符</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* current;	<span class="comment">// 词法分析器当前正在处理的Token的字符,一开始它就是start开始,直到遍历完整个Token,指向该Token的下一个字符</span></span><br><span class="line">	<span class="type">int</span> line;		<span class="comment">// 记录当前Token所处的行</span></span><br><span class="line">&#125; Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量结构体对象</span></span><br><span class="line"><span class="type">static</span> Scanner scanner;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initScanner</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* source)</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化全局变量Scanner</span></span><br><span class="line">	scanner.start = source;</span><br><span class="line">	scanner.current = source;</span><br><span class="line">	scanner.line = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面我给大家提供了很多会用到的辅助函数,建议使用</span></span><br><span class="line"><span class="comment">// 判断当前字符是不是字母或者下划线</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">isAlpha</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) ||</span><br><span class="line">		(c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) ||</span><br><span class="line">		c == <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断当前字符是不是数字</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">isDigit</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断Scanner当前正在处理的字符是不是空字符,判断是不是处理完了</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">isAtEnd</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *scanner.current == <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// curr指针前进一个字符,并返回之前curr指针指向的元素</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="title function_">advance</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *scanner.current++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查看当前正在处理的字符是什么,curr不动</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *scanner.current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前正在处理的字符不是空字符,那就瞥一眼下一个字符是什么,curr不动</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> <span class="title function_">peekNext</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (isAtEnd()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *(scanner.current + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前正在处理的字符是不是符合预期,如果符合curr前进一位</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">match</span><span class="params">(<span class="type">char</span> expected)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (isAtEnd()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">// 如果正在处理的是空字符,那就返回false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (peek() != expected) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">// 如果不符合预期,也返回false</span></span><br><span class="line">	&#125;</span><br><span class="line">	scanner.current++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// 只有符合预期才会返回true 而且curr会前进一位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据传入的TokenType类型来制造返回一个Token</span></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">makeToken</span><span class="params">(TokenType type)</span> &#123;</span><br><span class="line">	Token token;</span><br><span class="line">	token.type = type;</span><br><span class="line">	token.start = scanner.start;</span><br><span class="line">	token.length = (<span class="type">int</span>)(scanner.current - scanner.start);	<span class="comment">// 计算Token字符串的长度</span></span><br><span class="line">	token.line = scanner.line;</span><br><span class="line">	<span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到不能解析的情况时，我们创建一个ERROR Token. 比如：遇到@，$等符号时，比如字符串，字符没有对应的右引号时。</span></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">errorToken</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> &#123;</span><br><span class="line">	Token token;</span><br><span class="line">	token.type = TOKEN_ERROR;</span><br><span class="line">	token.start = message;</span><br><span class="line">	token.length = (<span class="type">int</span>)<span class="built_in">strlen</span>(message);</span><br><span class="line">	token.line = scanner.line;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//</span></span><br><span class="line">	<span class="comment">//fflush(stdout);</span></span><br><span class="line">	<span class="comment">//int a;</span></span><br><span class="line">	<span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">skipWhitespace</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 跳过空白字符: &#x27; &#x27;, &#x27;\r&#x27;, &#x27;\t&#x27;, &#x27;\n&#x27;和注释</span></span><br><span class="line">	<span class="comment">// 注释以&#x27;//&#x27;开头, 一直到行尾</span></span><br><span class="line">	<span class="comment">// 注意更新scanner.line！</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提示: 整个过程需要跳过中间的很多字符,所以需要死循环</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">char</span> ch = peek();</span><br><span class="line">		<span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span>(peekNext()==<span class="string">&#x27;/&#x27;</span>) </span><br><span class="line">			&#123; <span class="keyword">while</span> (advance() != <span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line">			scanner.line++;</span><br><span class="line">			&#125;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: advance(); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:advance(); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:advance(); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:scanner.line++; advance(); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>: scanner.start = scanner.current; <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于检查当前扫描的Token的类型是不是type 如果是就返回type</span></span><br><span class="line"><span class="type">static</span> TokenType <span class="title function_">checkKeyword</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> length, <span class="type">const</span> <span class="type">char</span>* rest, TokenType type)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		start: 待检查序列的起始字符下标</span></span><br><span class="line"><span class="comment">			比如要检查关键字break，那么在case b的前提下，需要传入reak来进行检查</span></span><br><span class="line"><span class="comment">			这里start就等于1，scanner.start[1]</span></span><br><span class="line"><span class="comment">		length: 待检查序列的长度，如果检查的是break，就是检查剩余的reak</span></span><br><span class="line"><span class="comment">			需要传入4</span></span><br><span class="line"><span class="comment">		rest指针，待检查的剩余序列字符串，这里直接传入一个字面值字符串就行了</span></span><br><span class="line"><span class="comment">			比如检查break，传入&quot;reak&quot;就好了</span></span><br><span class="line"><span class="comment">		type：你要检查的关键字Token的类型，比如检查break，那就传入Token_BREAK</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (scanner.current - scanner.start == start + length &amp;&amp;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">					int memcmp(const void *s1, const void *s2, size_t n);</span></span><br><span class="line"><span class="comment">					这里的参数分别是：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					s1：指向第一块内存区域的指针。</span></span><br><span class="line"><span class="comment">					s2：指向第二块内存区域的指针。</span></span><br><span class="line"><span class="comment">					n：要比较的字节数。</span></span><br><span class="line"><span class="comment">					memcmp 函数会逐字节比较 s1 和 s2 指向的内存区域，直到有不相等的字节或比较了 n 个字节为止。</span></span><br><span class="line"><span class="comment">					如果两个内存区域完全相同，</span></span><br><span class="line"><span class="comment">					则 memcmp 返回 0；如果第一个不同的字节在 s1 中的值小于 s2 中对应的值，返回负数；</span></span><br><span class="line"><span class="comment">					反之，返回正数。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="built_in">memcmp</span>(scanner.start + start, rest, length) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TOKEN_IDENTIFIER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TokenType <span class="title function_">identifierType</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 确定identifier类型主要有两种方式：</span></span><br><span class="line">	<span class="comment">// 1. 将所有的关键字放入哈希表中，然后查表确认 </span></span><br><span class="line">	<span class="comment">// Key-Value 就是&quot;关键字-TokenType&quot; 可以做 但存在额外内存占用且效率不如下一个方式好</span></span><br><span class="line">	<span class="comment">// 2. 将所有的关键字放入Trie树(字典查找树)中，然后查表确认</span></span><br><span class="line">	<span class="comment">// Trie树的方式不管是空间上还是时间上都优于哈希表的方式</span></span><br><span class="line">	<span class="comment">// 用switch...switch...if组合构建逻辑上的trie树</span></span><br><span class="line">	<span class="type">char</span> first = scanner.start[<span class="number">0</span>];	<span class="comment">// 该Token的第一个字符</span></span><br><span class="line">	<span class="keyword">switch</span> (first) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;reak&quot;</span>, TOKEN_BREAK);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: &#123;</span><br><span class="line">		<span class="type">char</span> second = scanner.start[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">switch</span> (second) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&quot;se&quot;</span>, TOKEN_CASE);</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&quot;ar&quot;</span>, TOKEN_CHAR);</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: &#123;</span><br><span class="line">			<span class="keyword">if</span> (scanner.start[<span class="number">3</span>] == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> checkKeyword(<span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;st&quot;</span>, TOKEN_CONST);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> checkKeyword(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&quot;tinue&quot;</span>, TOKEN_CONTINUE);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: &#123;</span><br><span class="line">		<span class="type">char</span> second = scanner.start[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (second == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> checkKeyword(<span class="number">2</span>, <span class="number">6</span>, <span class="string">&quot;efault&quot;</span>, TOKEN_DEFAULT);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (scanner.start[<span class="number">2</span>] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> checkKeyword(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;uble&quot;</span>, TOKEN_DOUBLE);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> checkKeyword(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;do&quot;</span>, TOKEN_DO);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: &#123;</span><br><span class="line">		<span class="type">char</span> second = scanner.start[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">switch</span> (second)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;lse&quot;</span>, TOKEN_ELSE);</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:<span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;num&quot;</span>, TOKEN_ENUM);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: &#123;</span><br><span class="line">		<span class="type">char</span> second = scanner.start[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (second == <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;loat&quot;</span>, TOKEN_FLOAT);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (second == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;or&quot;</span>, TOKEN_FOR);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;oto&quot;</span>, TOKEN_GOTO);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: &#123;</span><br><span class="line">		<span class="type">char</span> second = scanner.start[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (second == <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> checkKeyword(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;if&quot;</span>, TOKEN_IF);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (second = <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;nt&quot;</span>, TOKEN_INT);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:<span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&#x27;ONG&#x27;</span>, TOKEN_LONG);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:<span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">5</span>, <span class="string">&quot;eturn&quot;</span>, TOKEN_RETURN);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: &#123;</span><br><span class="line">		<span class="type">char</span> second = scanner.start[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">switch</span> (second)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:<span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;hort&quot;</span>, TOKEN_SHORT);</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: &#123;</span><br><span class="line">			<span class="type">char</span> third = scanner.start[<span class="number">2</span>];</span><br><span class="line">			<span class="keyword">if</span> (third == <span class="string">&#x27;g&#x27;</span>) <span class="keyword">return</span> checkKeyword(<span class="number">2</span>, <span class="number">4</span>, <span class="string">&#x27;gned&#x27;</span>, TOKEN_SIGNED);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (third == <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> checkKeyword(<span class="number">2</span>, <span class="number">4</span>, <span class="string">&#x27;ZEOF&#x27;</span>, TOKEN_SIZEOF);</span><br><span class="line">		&#125;</span><br><span class="line">				<span class="comment">//case &#x27;t&#x27;:return checkKeyword(1,5,&quot;tatic&quot;,TOKEN_STATIC )</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">5</span>, <span class="string">&quot;truct&quot;</span>, TOKEN_STRUCT);</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:<span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">5</span>, <span class="string">&quot;witch&quot;</span>, TOKEN_SWITCH);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">6</span>, <span class="string">&quot;ypedef&quot;</span>, TOKEN_TYPEDEF);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>: &#123;</span><br><span class="line">		<span class="type">char</span> third = scanner.start[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">if</span> (third == <span class="string">&#x27;i&#x27;</span>) <span class="keyword">return</span> checkKeyword(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;ion&quot;</span>, TOKEN_UNION);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (third == <span class="string">&#x27;s&#x27;</span>)<span class="keyword">return</span> checkKeyword(<span class="number">2</span>, <span class="number">6</span>, <span class="string">&quot;signed&quot;</span>, TOKEN_UNSIGNED);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>: <span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;oid&quot;</span>, TOKEN_VOID);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:<span class="keyword">return</span> checkKeyword(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;hile&quot;</span>, TOKEN_WHILE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没有进switch一定是标识符</span></span><br><span class="line">	<span class="keyword">return</span> TOKEN_IDENTIFIER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前Token的开头是下划线或字母判断它是不是标识符Token</span></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">identifier</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 判断curr指针当前正在处理的字符是不是 字母 下划线 数字</span></span><br><span class="line">	<span class="keyword">while</span> (isAlpha(peek()) || isDigit(peek())) &#123;</span><br><span class="line">		advance();  <span class="comment">// 继续前进看下一个字符 直到碰到下一个字符不是字母 下划线 以及数字 结束Token</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当while循环结束时，curr指针指向的是该Token字符串的下一个字符</span></span><br><span class="line">	<span class="comment">// 这个函数的意思是: 只要读到字母或下划线开头的Token我们就进入标识符模式</span></span><br><span class="line">	<span class="comment">// 然后一直找到此Token的末尾</span></span><br><span class="line">	<span class="comment">// 但代码运行到这里还不确定Token是标识符还是关键字, 因为它可能是break, var, goto, max_val...</span></span><br><span class="line">	<span class="comment">// 于是执行identifierType()函数，它是用来确定Token类型的</span></span><br><span class="line">	<span class="keyword">return</span> makeToken(identifierType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">number</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 简单起见，我们将NUMBER的规则定义如下:</span></span><br><span class="line">	<span class="comment">// 1. NUMBER可以包含数字和最多一个&#x27;.&#x27;号</span></span><br><span class="line">	<span class="comment">// 2. &#x27;.&#x27;号前面要有数字</span></span><br><span class="line">	<span class="comment">// 3. &#x27;.&#x27;号后面也要有数字</span></span><br><span class="line">	<span class="comment">// 这些都是合法的NUMBER: 123, 3.14</span></span><br><span class="line">	<span class="comment">// 这些都是不合法的NUMBER: 123., .14(虽然在C语言中合法)</span></span><br><span class="line">	<span class="comment">// 提示: 这个过程需要不断的跳过中间的数字包括小数点,所以也需要循环</span></span><br><span class="line">	<span class="type">int</span> point_count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (isDigit(peek()) || peek() == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">		<span class="type">char</span> ch = peek();</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (point_count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> errorToken(<span class="string">&quot;error number!&quot;</span>);<span class="comment">//小数点大于一个 不合法的number</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				point_count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//if (index == 0 &amp;&amp; ch == &#x27;.&#x27;) &#123;//.14这种类型的不合法number</span></span><br><span class="line">		<span class="comment">//	return errorToken(&quot;error number!&quot;);</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !isDigit(peekNext())) &#123;<span class="comment">//14. 这种类型的不合法number</span></span><br><span class="line">			<span class="keyword">return</span> errorToken(<span class="string">&quot;error number!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		advance();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> makeToken(TOKEN_NUMBER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">string</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 字符串以&quot;开头，以&quot;结尾，而且不能跨行</span></span><br><span class="line">	<span class="comment">// 为了简化工作量,简化了字符串</span></span><br><span class="line">	<span class="comment">// 如果下一个字符不是末尾也不是双引号，全部跳过(curr可以记录长度，不用担心)</span></span><br><span class="line">	<span class="keyword">while</span> (peek != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; peek != EOF &amp;&amp; peek() != <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">		advance();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (peek() == <span class="string">&#x27;&quot;&#x27;</span>) advance();</span><br><span class="line">	<span class="keyword">return</span> makeToken(TOKEN_STRING);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">character</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 字符&#x27;开头，以&#x27;结尾，而且不能跨行</span></span><br><span class="line">	<span class="comment">// 如果下一个字符不是末尾也不是单引号，全部跳过(curr可以记录长度，不用担心)</span></span><br><span class="line">	<span class="comment">// 这两个函数不能说一模一样，也是几乎一样</span></span><br><span class="line">	<span class="keyword">while</span> (peek != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; peek != EOF &amp;&amp; peek() != <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">		advance();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (peek() == <span class="string">&#x27;\&#x27;&#x27;</span>) advance();</span><br><span class="line">	<span class="keyword">return</span> makeToken(TOKEN_STRING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理无法识别的字符</span></span><br><span class="line"><span class="type">static</span> Token <span class="title function_">errorTokenWithChar</span><span class="params">(<span class="type">char</span> character)</span> &#123;</span><br><span class="line">	<span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line">	<span class="comment">// 将无法识别的字符是什么输出</span></span><br><span class="line">	<span class="built_in">sprintf</span>(message, <span class="string">&quot;Unexpected character: %c&quot;</span>, character);</span><br><span class="line">	<span class="keyword">return</span> errorToken(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scanner核心逻辑,用于返回一个制作好的Token</span></span><br><span class="line">Token <span class="title function_">scanToken</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 跳过前置空白字符和注释</span></span><br><span class="line">	skipWhitespace();</span><br><span class="line">	<span class="comment">// 记录下一个Token的起始位置</span></span><br><span class="line">	scanner.start = scanner.current;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果已经处理完毕了 直接返回TOKEN_EOF</span></span><br><span class="line">	<span class="keyword">if</span> (isAtEnd()) &#123;</span><br><span class="line">		<span class="keyword">return</span> makeToken(TOKEN_EOF);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// curr指针现在指向Token的第二个字符,但这个字符c仍然是第一个字符的值</span></span><br><span class="line">	<span class="type">char</span> c = advance();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果Token的第一个字符是字母和下划线就进入标识符的处理模式</span></span><br><span class="line">	<span class="keyword">if</span> (isAlpha(c)) &#123;</span><br><span class="line">		<span class="keyword">return</span> identifier();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果Token的第一个字符是数字,那就进入数字的处理模式</span></span><br><span class="line">	<span class="keyword">if</span> (isDigit(c)) &#123;</span><br><span class="line">		<span class="keyword">return</span> number();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果Token的第一个字符既不是数字也不是字母和下划线,那么就switch处理它</span></span><br><span class="line">	<span class="keyword">switch</span> (c) &#123;</span><br><span class="line">		<span class="comment">// 第一部分: 处理单字符Token</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">return</span> makeToken(TOKEN_LEFT_PAREN);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: <span class="keyword">return</span> makeToken(TOKEN_RIGHT_PAREN);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">return</span> makeToken(TOKEN_LEFT_BRACKET);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:<span class="keyword">return</span> makeToken(TOKEN_RIGHT_BRACKET);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: <span class="keyword">return</span> makeToken(TOKEN_LEFT_BRACE);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:<span class="keyword">return</span> makeToken(TOKEN_RIGHT_BRACE);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:<span class="keyword">return</span> makeToken(TOKEN_COMMA);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>:<span class="keyword">return</span> makeToken(TOKEN_DOT);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:<span class="keyword">return</span> makeToken(TOKEN_SEMICOLON);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;~&#x27;</span>:<span class="keyword">return</span> makeToken(TOKEN_TILDE);</span><br><span class="line">		<span class="comment">// 可单可双字符的Token处理会稍微复杂一点,但不多</span></span><br><span class="line">		<span class="comment">// 如果Token的第一个字符是+号</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">		<span class="comment">// 如果Token的第二个字符也是+,那就生产++双字符Token返回</span></span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;+&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_PLUS_PLUS);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_PLUS_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_PLUS);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_MINUS_MINUS);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_MINUS_GREATER);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">&#x27;&gt;&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_MINUS_GREATER);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_MINUS);</span><br><span class="line">		<span class="comment">// ...TODO</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_STAR_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_STAR);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_SLASH_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">&#x27;/&#x27;</span>)) skipWhitespace();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_SLASH);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_PERCENT_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_PERCENT);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_AMPER_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">&#x27;&amp;&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_AMPER_AMPER);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_AMPER);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_PIPE_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">&#x27;|&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_PIPE_PIPE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_PIPE);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_HAT_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_HAT);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_EQUAL_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_EQUAL);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_BANG_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_BANG);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_LESS_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">&#x27;&lt;&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_LESS_LESS);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_LESS);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (match(<span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_GREATER_EQUAL);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">&#x27;&gt;&#x27;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> makeToken(TOKEN_GREATER_GREATER);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> makeToken(TOKEN_GREATER);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>: <span class="keyword">return</span> <span class="built_in">string</span>(); <span class="comment">// 如果Token的第一个字符是双引号,那就解析出字符串Token返回</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>: <span class="keyword">return</span> character();	<span class="comment">// 如果Token的第一个字符是单引号,那就解析出字符Token返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果上述处理都没有处理成功,都没有生成合适的Token,说明该字符无法识别</span></span><br><span class="line">	<span class="keyword">return</span> errorTokenWithChar(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/huyue.github.io/about/"><img class="post-copyright__author_img_front" src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://api.qjqq.cn/api/MiYouShe"></a><div class="post-copyright__author_name">The Yue</div><div class="post-copyright__author_desc"></div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/huyue.github.io/">The Yue</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/huyue.github.io/tags/%E9%A1%B9%E7%9B%AE/"><span class="tags-punctuation"></span>项目<span class="tagsPageCount">1</span></a></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/huyue.github.io/2024/04/23/2024-4-23-%E5%B8%B8%E7%94%A8shell%E6%8C%87%E4%BB%A4-%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">常用shell指令-文件相关</div></div></a></div><div class="next-post pull-right"><a href="/huyue.github.io/2024/04/23/gdb%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">gdb调试工具使用手册</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://s21.ax1x.com/2024/04/16/pFxtXtK.png"></div><div class="author-info__description_group"><div class="author-info__description">分享自己对编程的<b>热爱</b>，对美好生活的<b>向往</b>，对知识海洋<b>探索历程</b>。</div><div class="author-info__description2">相信你可以在这里找到对你有用的知识和教程。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" target="_blank" rel="noopener" href="https://github.com/hu2271825073/huyue.github.io"><div class="author-info__name">胡越</div><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude st-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-text">小项目-词法分析器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%90%86%E8%AE%BA"><span class="toc-text">1.理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">1.1词法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">1.2 有限状态机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%88%E6%9E%9C"><span class="toc-text">2.效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6"><span class="toc-text">3.代码框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-text">4.实现词法分析器</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude st-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/huyue.github.io/2024/07/12/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/" title="Redis的基本概念"><img alt="Redis的基本概念" src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://api.qjqq.cn/api/Img?sort=acg&amp;random=341"></a><div class="content"><a class="title" href="/huyue.github.io/2024/07/12/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/" title="Redis的基本概念">Redis的基本概念</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/huyue.github.io/2024/07/11/ReactorV3V4V5/" title="ReactorV3V4V5"><img alt="ReactorV3V4V5" src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://api.qjqq.cn/api/Img?sort=acg&amp;random=985"></a><div class="content"><a class="title" href="/huyue.github.io/2024/07/11/ReactorV3V4V5/" title="ReactorV3V4V5">ReactorV3V4V5</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/huyue.github.io/2024/07/10/ReactorV2/" title="ReactorV2"><img alt="ReactorV2" src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://api.qjqq.cn/api/Img?sort=acg&amp;random=799"></a><div class="content"><a class="title" href="/huyue.github.io/2024/07/10/ReactorV2/" title="ReactorV2">ReactorV2</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/huyue.github.io/2024/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img alt="计算机网络" src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://api.qjqq.cn/api/Img?sort=acg&amp;random=777"></a><div class="content"><a class="title" href="/huyue.github.io/2024/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/huyue.github.io/2024/07/05/2024-7-5-c++%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="c++线程池"><img alt="c++线程池" src= "/huyue.github.io/img/loading.gif" data-lazy-src="https://api.qjqq.cn/api/Img?sort=acg&amp;random=957"></a><div class="content"><a class="title" href="/huyue.github.io/2024/07/05/2024-7-5-c++%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="c++线程池">c++线程池</a></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span class="solitude">越の博客</span></div><div class="footer-bar-description">来自The Yue - 的文章</div><a class="footer-bar-link" href="/huyue.github.io/">了解更多</a></div><div id="footer_deal"></div><div id="st-footer"><div class="footer-group"><h3 class="footer-title">导航</h3><div class="footer-links"><a class="footer-item" href="/huyue.github.io/archives/" title="归档">归档</a><a class="footer-item" href="/huyue.github.io/categories/" title="分类">分类</a><a class="footer-item" href="/huyue.github.io/tags/" title="标签">标签</a></div></div><div class="footer-group"><h3 class="footer-title">服务</h3><div class="footer-links"><a class="footer-item" target="_blank" rel="noopener" href="https://aliyun.com/" title="阿里云">阿里云</a><a class="footer-item" target="_blank" rel="noopener" href="https://v6.51.la/" title="51la统计">51la统计</a><a class="footer-item" target="_blank" rel="noopener" href="https://tongji.baidu.com/" title="百度统计">百度统计</a></div></div><div class="footer-group"><h3 class="footer-title">支持</h3><div class="footer-links"><a class="footer-item" href="/huyue.github.io/about/" title="打赏记录">打赏记录</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="/huyue.github.io/cookies/" title="Cookies">Cookies</a><a class="footer-item" href="/huyue.github.io/privacy/" title="用户协议">用户协议</a><a class="footer-item" href="/huyue.github.io/copyright/" title="版权协议">版权协议</a></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 By&nbsp;<a class="footer-bar-link" href="/huyue.github.io/">胡越</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/hu2271825073/huyue.github.io" alt="主题">主题</a><a class="footer-bar-link cc" href="/huyue.github.io/null" aria-label="copyright"><i class="solitude st-copyright-line"></i><i class="solitude st-creative-commons-by-line"></i><i class="solitude st-creative-commons-nc-line"></i><i class="solitude st-creative-commons-nd-line"></i></a></div></div></div></footer></div><!-- right_menu--><!-- inject body--><div><script src="/huyue.github.io/js/utils.js?v=1.8.6"></script><script src="/huyue.github.io/js/main.js?v=1.8.6"></script><script src="/huyue.github.io/js/third_party/waterfall.min.js?v=1.8.6"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/huyue.github.io/js/third_party/universe.min.js?v=1.8.6"></script><script>dark()
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/11.0.5/swiper-bundle.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/meting/2.0.1/Meting.min.js"></script><script>const meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';
</script><script src="/huyue.github.io/js/music.js?v=1.8.6"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="js-pjax"><script async src="https://cdnjs.cloudflare.com/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js"></script></div></div><!-- newest comment--><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined)
        document.documentElement.setAttribute('data-theme', 'dark');
    else
        document.documentElement.setAttribute('data-theme', cachedMode);
    is_rm && rm.mode(cachedMode === undefined || cachedMode === 'dark')
}
initTheme()</script><!-- google adsense--><!-- search--><!-- music--><div class="needEndHide" id="nav-music" onclick="sco.musicToggle()"><div id="nav-music-hoverTips">音乐已暂停</div><meting-js id="584817315" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" theme="var(--efu-main)"></meting-js></div></body></html><script>const posts=["2024/07/12/Redis数据库/","2024/07/11/ReactorV3V4V5/","2024/07/10/ReactorV2/","2024/07/09/计算机网络/","2024/07/05/2024-7-5-c++线程池/","2024/07/05/c++11线程库/","2024/07/02/2024-7-2-面向对象编程/","2024/07/01/2024-7-1-成员函数的适配器于空间配置器/","2024/06/28/2024-6-28-算法库/","2024/06/27/2024-6-27-STL四/","2024/06/26/2024-6-26-STL三/","2024/06/25/2024-6-25-STL二/","2024/06/24/2024-6-24-标准模板库/","2024/06/21/移动语义/","2024/06/21/2024-6-21-资源管理/","2024/06/20/2024-6-20-模板/","2024/06/19/2024-6-19-javaScript的常见类型和事件/","2024/06/19/2024-6-19-多态二/","2024/06/18/2024-6-13-多态/","2024/06/17/2024-6-17-继承/","2024/06/15/2024-6-15-小练习：RSS解析/","2024/06/15/2024-6-15-关联式容器二/","2024/06/14/2024-6-14-关联式容器/","2024/06/14/2024-6-14-stdstring的底层实现/","2024/06/14/2024-6-14-嵌套类二/","2024/06/13/2024-6-13-嵌套类/","2024/06/12/运算符重载二/","2024/06/12/运算符重载/","2024/06/12/日志系统的使用/","2024/06/08/explicit关键字/","2024/06/08/日志系统/","2024/06/08/c++输入输出流/","2024/06/06/leetcodesql_176 Second Highest Salary/","2024/06/04/inline函数/","2024/06/04/虚幻入门/","2024/06/04/引用/","2024/06/03/newdelete表达式/","2024/06/03/const关键字/","2024/05/25/分享会/","2024/05/25/sql语句/","2024/04/23/2024-4-23-常用shell指令-文件相关/","2024/04/23/2024-4-23-小项目-词法分析器/","2024/04/23/gdb调试工具使用手册/","2024/04/20/vim的一些其他操作/","2024/04/20/vim的常用快捷键总结/","2024/04/19/虚拟机扩容方法/","2024/04/18/高级排序算法/","2024/04/18/哈希表-用动态数组实现/","2024/04/17/单例模式/","2024/04/17/三种基本排序算法的实现/","2024/04/17/mrakdown使用说明/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); }</script>